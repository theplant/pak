{"name":"Pak","tagline":"Simple package management tool for Go.","body":"# Pak\r\n\r\nA go packages version control tool, inspired by Bundler for Ruby.\r\n\r\n## Quick Introduction\r\n\r\n* [Common Usage](http://ascii.io/a/5454)\r\n* [Partial Matching](http://ascii.io/a/5455)\r\n* [Pak Don't Hurt Unclean Packages](http://ascii.io/a/5456)\r\n\r\nBTW, this screenshots is made weeks ago, and pak has been improving all the time. So the output might be a bit of different now, however, the way pak works is still the same.\r\n\r\nPowerd by [ASCII.IO](http://ascii.io/).\r\n\r\n## What Pak Can Do\r\n\r\nAssume that you are working on two projects called pro1 and pro2, and they are both depending on two other projects working by your colleagues, req1 and req2.\r\n\r\n1. Req1 has two branches, branch1 and branch2. Req2 also has two branches, branch1 and branch2.\r\n2. Pro1 depends on branch1 in req1 and branch1 in req2, but pro2 depends on branch2 in req1 and branch2 in req2.\r\n3. Make it simple, supposed they are all using Git as their version control tool.\r\n4. Sometimes you are working on pro1, sometimes pro2. How to make yourself efficient and productive. Using one GOPATH you have to checkout stuff from req1 and req2. Using two GOPATH you have to switch GOPATH from time to time (may be there are better solution, but that's all I know. :-P).\r\n\r\nIf you use Pak. The workflow will be like this:\r\n\r\nMake Pakfiles in pro1 and pro2 like bellow:\r\n\r\nIn Pro1:\r\n\r\n```yaml\r\npackages:\r\n- name: github.com/theplant/req1\r\n  targetbranch: origin/branch1\r\n- name: github.com/theplant/req2\r\n  targetbranch: origin/branch1\r\n```\r\nIn Pro2:\r\n\r\n```yaml\r\npackages:\r\n- name: github.com/theplant/req1\r\n  targetbranch: origin/branch2\r\n- name: github.com/theplant/req2\r\n  targetbranch: origin/branch2\r\n```\r\n\r\nThen, when you are working on Pro1, you can did this:\r\n\r\n```\r\npak get\r\n```\r\n\r\nThis action will generates a file named `Pakfile.lock` in the first time that you use `pak`. It will retrieve the up-to-date checksum of packages specified in `Pakfile`. The next time you use `pak get`, pak will try to checkout req1 and req2 using the checksum saved in `Pakfile.lock`\r\n\r\n```\r\ngithub.com/theplant/req1: 6dd3a9a0e8349b0421c57c79b8f45d3565a96378\r\ngithub.com/theplant/req2: 5e1d544059ce1ff74d833da7f0d5a8ca02a82525\r\n```\r\n\r\nJust in pro2, you can do the same thing, it will generate a similar `Pakfile.lock`:\r\n\r\n```\r\ngithub.com/theplant/req1: 931b60b175dcfd6afa02d34e13270b8aaa4d0ba2\r\ngithub.com/theplant/req2: 1d1416e1f8fce75311d2afe5fc391aac84927601\r\n```\r\n\r\nWhen you go to package req1 or req2, you can see these two packages are on status that you specified in `Pakfile` and `Pakfile.lock`.\r\n\r\n## How Pak works\r\n\r\nThe mechanism of `pak` is pretty simple: Checking out the most up-to-date commit from all the dependences according to the description of `Pakfile` and then store the checksum in `Pakfile.lock`. It's like taking a snapshot of the dependences of your project and no matter how many changes is undergoing in them, each time when you need to run your project, just run `pak get` again then you can cancel all those changes (not actually delete them, just checkout those dependences accroding to `Pakfile.lock`). When you need to update some dependences in the project, just use `pak update`, then `pak` will checkout the up-to-date commit for you.\r\n\r\n## Usage\r\n\r\nInstallation is pretty simple:\r\n\r\n```\r\ngo get github.com/theplant/pak\r\n```\r\n\r\nThen done. See avaliable actions:\r\n\r\n```\r\n$: pak\r\nUsage:\r\n    pak init\r\n    pak [-sf] get [package]\r\n    pak [-s] update [package]\r\n    pak open [package]\r\n    pak list\r\n    pak version\r\n  -f=false: Force pak to remove pak branch or pak unclean packages.\r\n  -s=false: Skip unclean packages.\r\n```\r\n\r\n### Init and Configuration\r\n\r\n```\r\npak init\r\n```\r\n\r\nThis Command will generate a file named Pakfile in which you can write down dependences that your project needs.\r\n\r\nPakfile is using YAML syntax.\r\n\r\nA sample:\r\n\r\n```yaml\r\npackages:\r\n- name: github.com/theplant/package1\r\n  pakname: pak\r\n  targetbranch: origin/master\r\n- name: github.com/theplant/package1\r\n  pakname: pak\r\n  targetbranch: origin/master\r\n```\r\n\r\nAll package requirements should be listed in packages section. Each package contains some descriptions which are explained below:\r\n\r\n`name`: the package name.\r\n\r\n`pakname`: a name pak used to checkout a branch/bookmark in dependent packages, default value is pak.\r\n\r\n`targetbranch`: the branch which you need pak to monitor, default values in git is `origin/master` and `default/default` in mercurial. It must be a remote branch.\r\n\r\nEvery dependences in Pakfile must have a remote repository. Pak will only try to checkout them from that remote repository. The reason behind this is `pak` is designed to be an cooperating tool first then an package management tool. And a package without remote repository is difficult to share with your teammates and other nice guys on Internet.\r\n\r\n### Pak Get\r\n\r\nAfter finishing a Pakfile, using `pak get` to take the first snapshot of your project's dependences. That will generate a Pakfile.lock by retrieving the up-to-date checksum from the remote repositories of your dependences.\r\n\r\nWithout the exitstence of `Pakfile.lock`, `pak` will try to checkout the up-to-date commit according to descriptions of `Pakfile`. So after the first time that you use `pak get`, pak creates `Pakfile.lock`. With the existence of `Pakfile.lock`, `pak get` will checkout commits recorded in `Pakfile.lock` from your dependences.\r\n\r\n`pak get` supports you to get specific packages like this:\r\n\r\n```\r\npak get some-package\r\n```\r\n\r\nBTW, pak support partial matching, you don't have to type the whole name of that packages.\r\n\r\n### Pak Update\r\n\r\nAfter paking some packages for a while, you might be to update some of the packages, here comes `pak update`.\r\n\r\nWhen running `pak update`, pak will retrieve the up-to-date commits from the remote repository and lock them in `Pakfile.lock`.\r\n\r\nAlso if you don't want to update all dependences (which is slow and might not be unnecessary in some cases), you can specify need-to-update packages like this:\r\n\r\n```\r\npak update some-package\r\n```\r\n\r\n### Pak Check\r\n\r\nA feature serve as a reminder in your application to help you detect whether the dependences is consistent with your Pakfile.lock. Save you from debugging problems caused by inconsistency in dependences. When\r\n\r\nIn your package, use it as bellow:\r\n\r\n```go\r\nimport pak \"github.com/theplant/pak/check\"\r\n\r\nfunc init() {\r\n    pak.Check()\r\n}\r\n```\r\n\r\nAnd each time you start your app, pak will auto check the dependencies of your app. if your app is not consistent with Pakfile and Pakfile.lock, it will force your app to exit. Like this:\r\n\r\n![Check](https://raw.github.com/theplant/pak/master/imgs/check.png?login=bom-d-van&token=93b3b310df07f7163a3b57efe9fa0ada)\r\n\r\nNote: It's recommended to use pak.check in your development environemnt instead of production environment. This's mainly a tool for developers.\r\n\r\n## Status\r\n\r\nSupported Version Control System: Git, Mercurial.\r\n\r\nFeatures:\r\n\r\n* Cross Package Dependences\r\n* Auto Detect Package Dependences (pak.Check)\r\n\r\n## License\r\n\r\nPak is released under the [MIT License](http://www.opensource.org/licenses/MIT).\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}